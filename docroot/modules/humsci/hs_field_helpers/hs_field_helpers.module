<?php

/**
 * @file
 * hs_field_helpers.module
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Layout\LayoutDefinition;
use Drupal\Core\Render\Element;
use Drupal\Core\Entity\EntityInterface;
use Drupal\hs_field_helpers\Plugin\Field\FieldType\DisplayModeField;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\Core\Entity\Entity\EntityViewDisplay;
use Drupal\Core\Field\FormatterInterface;
use Drupal\layout_builder\Entity\LayoutBuilderEntityViewDisplay;
use Drupal\Core\Field\FieldDefinitionInterface;

/**
 * Implements hook_help().
 */
function hs_field_helpers_help($route_name, RouteMatchInterface $route_match) {
  if (strpos($route_name, 'entity.entity_view_display.') === FALSE) {
    return;
  }

  /** @var FieldConfig $field */
  foreach (FieldConfig::loadMultiple() as $field) {
    if ($field->getType() != 'display_mode_field') {
      continue;
    }

    $entity_type = $field->getTargetEntityTypeId();
    $entity_bundle = $field->getTargetBundle();
    $field_view_modes = $field->getFieldStorageDefinition()
      ->getSetting('allowed_values');

    // Display help text to the user configuring the view mode. This prevents
    // needing to switch back and forth to remember which display "label" is
    // being edited.
    foreach ($field_view_modes as $display_id => $label) {
      if ($route_match->getParameter('bundle') == $entity_bundle &&
        $route_match->getParameter('entity_type_id') == $entity_type &&
        $route_match->getParameter('view_mode_name') == $display_id
      ) {
        return t('This display mode is displayed to the user as %label', ['%label' => $label]);
      }
    }
    $field->getEntityTypeId();
  }
}

/**
 * Implements hook_entity_view_mode_alter().
 */
function hs_field_helpers_entity_view_mode_alter(&$view_mode, EntityInterface $entity, $context) {
  if ($entity instanceof FieldableEntityInterface) {
    $view_mode = DisplayModeField::getDisplayMode($entity) ?: $view_mode;
  }
}

/**
 * Implements hook_field_widget_info_alter().
 */
function hs_field_helpers_field_widget_info_alter(array &$info) {
  $info['options_select']['field_types'][] = 'display_mode_field';
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function hs_field_helpers_field_formatter_info_alter(array &$info) {
  $info['list_default']['field_types'][] = 'display_mode_field';
}

//function hs_field_helpers_context

/**
 * Implements hook_preprocess().
 */
function hs_field_helpers_preprocess(&$variables, $hook) {
  // Each layout has its own preprocess hook. So we have to use generic hook.
  if (isset($variables['layout']) && $variables['layout'] instanceof LayoutDefinition) {

    // This attribute exists when on the layout management page. We don't want
    // to clean up the regions when on that page because it will break the UI.
    if (!empty($variables['attributes']['data-layout-update-url'])) {
      return;
    }

    foreach (Element::children($variables['content']) as $region) {

      // Some blocks such as a menu block don't have any output, but the layout
      // still outputs an empty container for the block that has no content.
      // So lets find out if they are empty, and clean them up.
      foreach (Element::children($variables['content'][$region]) as $item_id) {
        if (empty($variables['content'][$region][$item_id]['#theme'])) {
          unset($variables['content'][$region][$item_id]);
        }
      }

      // Clean up empty regions after we've cleaned up the blocks in the region.
      if (empty(Element::children($variables['content'][$region]))) {
        unset($variables['content'][$region]);
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function hs_field_helpers_form_field_config_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\field\Entity\FieldConfig $field_config */
  $field_config = $form_state->getBuildInfo()['callback_object']->getEntity();
  // Add an option to exclude views from the form. The module only has the
  // "allowed views" option. This hides the allowed views and adds the excluded
  // views.
  if ($field_config->getType() == 'viewfield') {
    $form['third_party_settings']['hs_field_helpers']['excluded_views'] = [
      '#type' => 'checkboxes',
      '#title' => t('Excluded views'),
      '#options' => $form['settings']['allowed_views']['#options'],
      '#default_value' => $field_config->getThirdPartySetting('hs_field_helpers', 'excluded_views') ?: [],
    ];
    $form['#validate'][] = 'hs_field_helpers_form_field_config_edit_form_validate';
  }
}

/**
 * Validation handler for field config edit form.
 */
function hs_field_helpers_form_field_config_edit_form_validate(&$form, FormStateInterface $form_state) {
  if ($excluded_views = &$form_state->getValue([
    'third_party_settings',
    'hs_field_helpers',
    'excluded_views',
  ])) {
    // Remove keys on the values to make the config cleaner.
    $excluded_views = array_filter(array_values($excluded_views));
  }
}

/**
 * Implements hook_field_widget_form_alter().
 */
function hs_field_helpers_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  /** @var \Drupal\Core\Field\WidgetBaseInterface $widget */
  $widget = $context['widget'];

  switch ($widget->getPluginId()) {
    case 'viewfield_select':
      /** @var \Drupal\field\Entity\FieldConfig $field_config */
      $field_config = $context['items']->getFieldDefinition();
      // Strip the view options as defined by the exclude views settings.
      // @see hs_field_helpers_form_field_config_edit_form_alter().
      if ($excluded_views = $field_config->getThirdPartySetting('hs_field_helpers', 'excluded_views')) {
        $element['target_id']['#options'] = array_diff_key($element['target_id']['#options'], array_flip($excluded_views));
      }
      // Chosen & Material Admin conflicts with this select list during ajax.
      // The easiest way to fix is to disable those libraries.
      $element['display_id']['#attributes']['class'][] = 'browser-default';
      break;

    case 'daterange_datelist':
    case 'daterange_default':
      // To simulate the same field functionality as we had in D7, we need to
      // add a checkbox and validation handlers.
      // Adds wrappers so we can easily find the parts with jQuery.
      $element['value']['#prefix'] = '<div class="start-date">';
      $element['value']['#suffix'] = '</div>';
      $element['end_value']['#prefix'] = '<div class="end-date">';
      $element['end_value']['#suffix'] = '</div>';

      $show_end = FALSE;

      // Compare start and end dates to determine default checkbox value.
      if (!empty($element['value']['#default_value']) && !empty($element['end_value']['#default_value'])) {
        /** @var \DateInterval $diff */
        $diff = $element['value']['#default_value']->diff($element['end_value']['#default_value']);
        $show_end = (bool) (int) $diff->format('%Y%M%D%H%I%S');
      }

      $element['show_end'] = [
        '#type' => 'checkbox',
        '#title' => t('Show End Date'),
        '#default_value' => $show_end,
        '#attributes' => ['class' => ['show-end-date']],
      ];

      $element['#attached']['library'][] = 'hs_field_helpers/admin';
      array_unshift($element['#element_validate'], 'hs_field_helpers_node_validate_date');

      break;
  }
  $element['#attached']['library'][] = 'hs_field_helpers/admin';
}

/**
 * Validation for event dates in nodes form.
 */
function hs_field_helpers_node_validate_date(array &$element, FormStateInterface $form_state) {
  $date = $form_state->getValue('field_hs_event_date');

  // If the start value is populated but end is empty, copy the start date
  // to the end date to pass validation.
  if (!empty($date[0]['value']) && (!$date[0]['show_end'] || empty($date[0]['end_value']))) {
    $date[0]['end_value'] = $date[0]['value'];
    $element['end_value']['#value']['object'] = $date[0]['end_value'];

    /** @var \Drupal\Core\Datetime\DrupalDateTime $date */
    $form_state->setValue('field_hs_event_date', $date);
  }
}

/**
 * Implements hook_preprocess_views_view_pattern().
 */
function hs_field_helpers_preprocess_views_view_pattern(&$variables) {
  /** @var \Drupal\views\ViewExecutable $view */
  $view = $variables['view'];
  $pattern = $view->style_plugin->options['pattern'];
  $variables['pattern'] = $pattern;
}

/**
 * Implements hook_field_formatter_settings_summary_alter().
 */
function hs_field_helpers_field_formatter_settings_summary_alter(&$summary, $context) {
  $inline = $context['formatter']->getThirdPartySetting('hs_field_helpers', 'inline_contents');
  if (!empty($inline)) {
    $summary[] = t('Inline Contents: @inline', ['@inline' => $inline ? t('Yes') : t('No')]);
  }
}

/**
 * Implements hook_field_formatter_third_party_settings_form().
 *
 * Adds a 'class' textfield to all formatters.
 */
function hs_field_helpers_field_formatter_third_party_settings_form(FormatterInterface $plugin, FieldDefinitionInterface $field_definition, $view_mode, $form, FormStateInterface $form_state) {
  $element['inline_contents'] = [
    '#type' => 'checkbox',
    '#title' => t('Inline Contents'),
    '#description' => t('Display the field items as comma separated values.'),
    '#default_value' => $plugin->getThirdPartySetting('hs_field_helpers', 'inline_contents'),
  ];
  return $element;
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * The field_formatter_class module doesn't work on layout builder fields, so we
 * have to add our classes on our own.
 *
 * @see field_formatter_class_preprocess_field().
 */
function hs_field_helpers_preprocess_field(&$variables) {
  // Get a few convenient handles.
  $entity = $variables['element']['#object'];
  $field_name = $variables['element']['#field_name'];
  $view_mode = $variables['element']['#view_mode'];

  // Drill down to field formatter settings.
  $render_display = EntityViewDisplay::collectRenderDisplay($entity, $view_mode);
  // Anything else should be handled by field_formatter_class.
  if (!($render_display instanceof LayoutBuilderEntityViewDisplay)) {
    return;
  }
  $field_display = _hs_field_helpers_get_view_mode_component($render_display, $field_name);

  // Add class for whole field.
  if (!empty($field_display['third_party_settings']['field_formatter_class'])) {
    $variables['attributes']['class'][] = $field_display['third_party_settings']['field_formatter_class']['class'];
  }
}

/**
 * Implements hook_theme_suggestions_HOOK().
 *
 * Adds a theme suggestion to make all contents be inline. Then our theme can
 * take that suggestion and run with it.
 */
function hs_field_helpers_theme_suggestions_field(array $variables) {

  // Get a few convenient handles.
  /** @var FieldableEntityInterface $entity */
  $entity = $variables['element']['#object'];
  $field_name = $variables['element']['#field_name'];
  $view_mode = $variables['element']['#view_mode'];

  // Drill down to field formatter settings.
  /** @var \Drupal\layout_builder\Entity\LayoutBuilderEntityViewDisplay $render_display */
  $render_display = EntityViewDisplay::collectRenderDisplay($entity, $view_mode);
  $field_display = _hs_field_helpers_get_view_mode_component($render_display, $field_name);

  $suggestions = [];
  // Add class for whole field.
  if (isset($field_display['third_party_settings']['hs_field_helpers']) && $field_display['third_party_settings']['hs_field_helpers']) {
    $entity_type = $entity->getEntityTypeId();
    $suggestions = [
      'field__inline_contents',
      "field__inline_contents__$field_name",
      "field__inline_contents__$entity_type",
    ];
  }
  return $suggestions;
}

/**
 * A field can be nested in a layout builder section, so lets go get it.
 *
 * @param \Drupal\layout_builder\Entity\LayoutBuilderEntityViewDisplay $entity_display
 *   Display entity.
 * @param string $field_name
 *   Field name to find.
 *
 * @return array|null
 *   Formatter settings of the field if found.
 */
function _hs_field_helpers_get_view_mode_component(LayoutBuilderEntityViewDisplay $entity_display, $field_name) {
  $entity_type = $entity_display->getTargetEntityTypeId();
  $entity_bundle = $entity_display->getTargetBundle();
  $id = "field_block:$entity_type:$entity_bundle:$field_name";

  /** @var \Drupal\layout_builder\Section $section */
  foreach ($entity_display->getSections() as $section) {
    /** @var \Drupal\layout_builder\SectionComponent $component */
    foreach ($section->getComponents() as $component) {
      $config = $component->get('configuration');
      if ($config['id'] == $id) {
        return $config['formatter'];
      }
    }
  }
}
